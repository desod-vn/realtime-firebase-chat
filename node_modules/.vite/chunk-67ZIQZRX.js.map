{
  "version": 3,
  "sources": ["../idb/lib/idb.mjs", "../@firebase/installations/src/util/constants.ts", "../@firebase/installations/src/util/errors.ts", "../@firebase/installations/src/functions/common.ts", "../@firebase/installations/src/functions/create-installation-request.ts", "../@firebase/installations/src/util/sleep.ts", "../@firebase/installations/src/helpers/buffer-to-base64-url-safe.ts", "../@firebase/installations/src/helpers/generate-fid.ts", "../@firebase/installations/src/util/get-key.ts", "../@firebase/installations/src/helpers/fid-changed.ts", "../@firebase/installations/src/helpers/idb-manager.ts", "../@firebase/installations/src/helpers/get-installation-entry.ts", "../@firebase/installations/src/functions/generate-auth-token-request.ts", "../@firebase/installations/src/helpers/refresh-auth-token.ts", "../@firebase/installations/src/api/get-id.ts", "../@firebase/installations/src/api/get-token.ts", "../@firebase/installations/src/functions/delete-installation-request.ts", "../@firebase/installations/src/api/delete-installations.ts", "../@firebase/installations/src/api/on-id-change.ts", "../@firebase/installations/src/api/get-installations.ts", "../@firebase/installations/src/helpers/extract-app-config.ts", "../@firebase/installations/src/functions/config.ts", "../@firebase/installations/src/index.ts"],
  "sourcesContent": ["function toArray(arr) {\n  return Array.prototype.slice.call(arr);\n}\n\nfunction promisifyRequest(request) {\n  return new Promise(function(resolve, reject) {\n    request.onsuccess = function() {\n      resolve(request.result);\n    };\n\n    request.onerror = function() {\n      reject(request.error);\n    };\n  });\n}\n\nfunction promisifyRequestCall(obj, method, args) {\n  var request;\n  var p = new Promise(function(resolve, reject) {\n    request = obj[method].apply(obj, args);\n    promisifyRequest(request).then(resolve, reject);\n  });\n\n  p.request = request;\n  return p;\n}\n\nfunction promisifyCursorRequestCall(obj, method, args) {\n  var p = promisifyRequestCall(obj, method, args);\n  return p.then(function(value) {\n    if (!value) return;\n    return new Cursor(value, p.request);\n  });\n}\n\nfunction proxyProperties(ProxyClass, targetProp, properties) {\n  properties.forEach(function(prop) {\n    Object.defineProperty(ProxyClass.prototype, prop, {\n      get: function() {\n        return this[targetProp][prop];\n      },\n      set: function(val) {\n        this[targetProp][prop] = val;\n      }\n    });\n  });\n}\n\nfunction proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return promisifyRequestCall(this[targetProp], prop, arguments);\n    };\n  });\n}\n\nfunction proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return this[targetProp][prop].apply(this[targetProp], arguments);\n    };\n  });\n}\n\nfunction proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n    };\n  });\n}\n\nfunction Index(index) {\n  this._index = index;\n}\n\nproxyProperties(Index, '_index', [\n  'name',\n  'keyPath',\n  'multiEntry',\n  'unique'\n]);\n\nproxyRequestMethods(Index, '_index', IDBIndex, [\n  'get',\n  'getKey',\n  'getAll',\n  'getAllKeys',\n  'count'\n]);\n\nproxyCursorRequestMethods(Index, '_index', IDBIndex, [\n  'openCursor',\n  'openKeyCursor'\n]);\n\nfunction Cursor(cursor, request) {\n  this._cursor = cursor;\n  this._request = request;\n}\n\nproxyProperties(Cursor, '_cursor', [\n  'direction',\n  'key',\n  'primaryKey',\n  'value'\n]);\n\nproxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n  'update',\n  'delete'\n]);\n\n// proxy 'next' methods\n['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n  if (!(methodName in IDBCursor.prototype)) return;\n  Cursor.prototype[methodName] = function() {\n    var cursor = this;\n    var args = arguments;\n    return Promise.resolve().then(function() {\n      cursor._cursor[methodName].apply(cursor._cursor, args);\n      return promisifyRequest(cursor._request).then(function(value) {\n        if (!value) return;\n        return new Cursor(value, cursor._request);\n      });\n    });\n  };\n});\n\nfunction ObjectStore(store) {\n  this._store = store;\n}\n\nObjectStore.prototype.createIndex = function() {\n  return new Index(this._store.createIndex.apply(this._store, arguments));\n};\n\nObjectStore.prototype.index = function() {\n  return new Index(this._store.index.apply(this._store, arguments));\n};\n\nproxyProperties(ObjectStore, '_store', [\n  'name',\n  'keyPath',\n  'indexNames',\n  'autoIncrement'\n]);\n\nproxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n  'put',\n  'add',\n  'delete',\n  'clear',\n  'get',\n  'getAll',\n  'getKey',\n  'getAllKeys',\n  'count'\n]);\n\nproxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n  'openCursor',\n  'openKeyCursor'\n]);\n\nproxyMethods(ObjectStore, '_store', IDBObjectStore, [\n  'deleteIndex'\n]);\n\nfunction Transaction(idbTransaction) {\n  this._tx = idbTransaction;\n  this.complete = new Promise(function(resolve, reject) {\n    idbTransaction.oncomplete = function() {\n      resolve();\n    };\n    idbTransaction.onerror = function() {\n      reject(idbTransaction.error);\n    };\n    idbTransaction.onabort = function() {\n      reject(idbTransaction.error);\n    };\n  });\n}\n\nTransaction.prototype.objectStore = function() {\n  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n};\n\nproxyProperties(Transaction, '_tx', [\n  'objectStoreNames',\n  'mode'\n]);\n\nproxyMethods(Transaction, '_tx', IDBTransaction, [\n  'abort'\n]);\n\nfunction UpgradeDB(db, oldVersion, transaction) {\n  this._db = db;\n  this.oldVersion = oldVersion;\n  this.transaction = new Transaction(transaction);\n}\n\nUpgradeDB.prototype.createObjectStore = function() {\n  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n};\n\nproxyProperties(UpgradeDB, '_db', [\n  'name',\n  'version',\n  'objectStoreNames'\n]);\n\nproxyMethods(UpgradeDB, '_db', IDBDatabase, [\n  'deleteObjectStore',\n  'close'\n]);\n\nfunction DB(db) {\n  this._db = db;\n}\n\nDB.prototype.transaction = function() {\n  return new Transaction(this._db.transaction.apply(this._db, arguments));\n};\n\nproxyProperties(DB, '_db', [\n  'name',\n  'version',\n  'objectStoreNames'\n]);\n\nproxyMethods(DB, '_db', IDBDatabase, [\n  'close'\n]);\n\n// Add cursor iterators\n// TODO: remove this once browsers do the right thing with promises\n['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n  [ObjectStore, Index].forEach(function(Constructor) {\n    // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n    if (!(funcName in Constructor.prototype)) return;\n\n    Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n      var args = toArray(arguments);\n      var callback = args[args.length - 1];\n      var nativeObject = this._store || this._index;\n      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n      request.onsuccess = function() {\n        callback(request.result);\n      };\n    };\n  });\n});\n\n// polyfill getAll\n[Index, ObjectStore].forEach(function(Constructor) {\n  if (Constructor.prototype.getAll) return;\n  Constructor.prototype.getAll = function(query, count) {\n    var instance = this;\n    var items = [];\n\n    return new Promise(function(resolve) {\n      instance.iterateCursor(query, function(cursor) {\n        if (!cursor) {\n          resolve(items);\n          return;\n        }\n        items.push(cursor.value);\n\n        if (count !== undefined && items.length == count) {\n          resolve(items);\n          return;\n        }\n        cursor.continue();\n      });\n    });\n  };\n});\n\nexport function openDb(name, version, upgradeCallback) {\n  var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n  var request = p.request;\n\n  if (request) {\n    request.onupgradeneeded = function(event) {\n      if (upgradeCallback) {\n        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n      }\n    };\n  }\n\n  return p.then(function(db) {\n    return new DB(db);\n  });\n}\n\nexport function deleteDb(name) {\n  return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { version } from '../../package.json';\n\nexport const PENDING_TIMEOUT_MS = 10000;\n\nexport const PACKAGE_VERSION = `w:${version}`;\nexport const INTERNAL_AUTH_VERSION = 'FIS_v2';\n\nexport const INSTALLATIONS_API_URL =\n  'https://firebaseinstallations.googleapis.com/v1';\n\nexport const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\n\nexport const SERVICE = 'installations';\nexport const SERVICE_NAME = 'Installations';\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { SERVICE, SERVICE_NAME } from './constants';\n\nexport const enum ErrorCode {\n  MISSING_APP_CONFIG_VALUES = 'missing-app-config-values',\n  NOT_REGISTERED = 'not-registered',\n  INSTALLATION_NOT_FOUND = 'installation-not-found',\n  REQUEST_FAILED = 'request-failed',\n  APP_OFFLINE = 'app-offline',\n  DELETE_PENDING_REGISTRATION = 'delete-pending-registration'\n}\n\nconst ERROR_DESCRIPTION_MAP: { readonly [key in ErrorCode]: string } = {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]:\n    'Missing App configuration value: \"{$valueName}\"',\n  [ErrorCode.NOT_REGISTERED]: 'Firebase Installation is not registered.',\n  [ErrorCode.INSTALLATION_NOT_FOUND]: 'Firebase Installation not found.',\n  [ErrorCode.REQUEST_FAILED]:\n    '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n  [ErrorCode.APP_OFFLINE]: 'Could not process request. Application offline.',\n  [ErrorCode.DELETE_PENDING_REGISTRATION]:\n    \"Can't delete installation while there is a pending registration request.\"\n};\n\ninterface ErrorParams {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]: {\n    valueName: string;\n  };\n  [ErrorCode.REQUEST_FAILED]: {\n    requestName: string;\n    [index: string]: string | number; // to make Typescript 3.8 happy\n  } & ServerErrorData;\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<ErrorCode, ErrorParams>(\n  SERVICE,\n  SERVICE_NAME,\n  ERROR_DESCRIPTION_MAP\n);\n\nexport interface ServerErrorData {\n  serverCode: number;\n  serverMessage: string;\n  serverStatus: string;\n}\n\nexport type ServerError = FirebaseError & { customData: ServerErrorData };\n\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\nexport function isServerError(error: unknown): error is ServerError {\n  return (\n    error instanceof FirebaseError &&\n    error.code.includes(ErrorCode.REQUEST_FAILED)\n  );\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport {\n  INSTALLATIONS_API_URL,\n  INTERNAL_AUTH_VERSION\n} from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\nimport { AppConfig } from '../interfaces/installation-impl';\n\nexport function getInstallationsEndpoint({ projectId }: AppConfig): string {\n  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\n}\n\nexport function extractAuthTokenInfoFromResponse(\n  response: GenerateAuthTokenResponse\n): CompletedAuthToken {\n  return {\n    token: response.token,\n    requestStatus: RequestStatus.COMPLETED,\n    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n    creationTime: Date.now()\n  };\n}\n\nexport async function getErrorFromResponse(\n  requestName: string,\n  response: Response\n): Promise<FirebaseError> {\n  const responseJson: ErrorResponse = await response.json();\n  const errorData = responseJson.error;\n  return ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {\n    requestName,\n    serverCode: errorData.code,\n    serverMessage: errorData.message,\n    serverStatus: errorData.status\n  });\n}\n\nexport function getHeaders({ apiKey }: AppConfig): Headers {\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n\nexport function getHeadersWithAuth(\n  appConfig: AppConfig,\n  { refreshToken }: RegisteredInstallationEntry\n): Headers {\n  const headers = getHeaders(appConfig);\n  headers.append('Authorization', getAuthorizationHeader(refreshToken));\n  return headers;\n}\n\nexport interface ErrorResponse {\n  error: {\n    code: number;\n    message: string;\n    status: string;\n  };\n}\n\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */\nexport async function retryIfServerError(\n  fn: () => Promise<Response>\n): Promise<Response> {\n  const result = await fn();\n\n  if (result.status >= 500 && result.status < 600) {\n    // Internal Server Error. Retry request.\n    return fn();\n  }\n\n  return result;\n}\n\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn: string): number {\n  // This works because the server will never respond with fractions of a second.\n  return Number(responseExpiresIn.replace('s', '000'));\n}\n\nfunction getAuthorizationHeader(refreshToken: string): string {\n  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CreateInstallationResponse } from '../interfaces/api-response';\nimport {\n  InProgressInstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { INTERNAL_AUTH_VERSION, PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeaders,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\nimport { AppConfig } from '../interfaces/installation-impl';\n\nexport async function createInstallationRequest(\n  appConfig: AppConfig,\n  { fid }: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  const endpoint = getInstallationsEndpoint(appConfig);\n\n  const headers = getHeaders(appConfig);\n  const body = {\n    fid,\n    authVersion: INTERNAL_AUTH_VERSION,\n    appId: appConfig.appId,\n    sdkVersion: PACKAGE_VERSION\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: CreateInstallationResponse = await response.json();\n    const registeredInstallationEntry: RegisteredInstallationEntry = {\n      fid: responseValue.fid || fid,\n      registrationStatus: RequestStatus.COMPLETED,\n      refreshToken: responseValue.refreshToken,\n      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n    };\n    return registeredInstallationEntry;\n  } else {\n    throw await getErrorFromResponse('Create Installation', response);\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Returns a promise that resolves after given time passes. */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function bufferToBase64UrlSafe(array: Uint8Array): string {\n  const b64 = btoa(String.fromCharCode(...array));\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bufferToBase64UrlSafe } from './buffer-to-base64-url-safe';\n\nexport const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nexport const INVALID_FID = '';\n\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */\nexport function generateFid(): string {\n  try {\n    // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n    // bytes. our implementation generates a 17 byte array instead.\n    const fidByteArray = new Uint8Array(17);\n    const crypto =\n      self.crypto || (self as unknown as { msCrypto: Crypto }).msCrypto;\n    crypto.getRandomValues(fidByteArray);\n\n    // Replace the first 4 random bits with the constant FID header of 0b0111.\n    fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n\n    const fid = encode(fidByteArray);\n\n    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n  } catch {\n    // FID generation errored\n    return INVALID_FID;\n  }\n}\n\n/** Converts a FID Uint8Array to a base64 string representation. */\nfunction encode(fidByteArray: Uint8Array): string {\n  const b64String = bufferToBase64UrlSafe(fidByteArray);\n\n  // Remove the 23rd character that was added because of the extra 4 bits at the\n  // end of our 17 byte array, and the '=' padding.\n  return b64String.substr(0, 22);\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/installation-impl';\n\n/** Returns a string key that can be used to identify the app. */\nexport function getKey(appConfig: AppConfig): string {\n  return `${appConfig.appName}!${appConfig.appId}`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getKey } from '../util/get-key';\nimport { AppConfig } from '../interfaces/installation-impl';\nimport { IdChangeCallbackFn } from '../api';\n\nconst fidChangeCallbacks: Map<string, Set<IdChangeCallbackFn>> = new Map();\n\n/**\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\n * change to other tabs.\n */\nexport function fidChanged(appConfig: AppConfig, fid: string): void {\n  const key = getKey(appConfig);\n\n  callFidChangeCallbacks(key, fid);\n  broadcastFidChange(key, fid);\n}\n\nexport function addCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  // Open the broadcast channel if it's not already open,\n  // to be able to listen to change events from other tabs.\n  getBroadcastChannel();\n\n  const key = getKey(appConfig);\n\n  let callbackSet = fidChangeCallbacks.get(key);\n  if (!callbackSet) {\n    callbackSet = new Set();\n    fidChangeCallbacks.set(key, callbackSet);\n  }\n  callbackSet.add(callback);\n}\n\nexport function removeCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  const key = getKey(appConfig);\n\n  const callbackSet = fidChangeCallbacks.get(key);\n\n  if (!callbackSet) {\n    return;\n  }\n\n  callbackSet.delete(callback);\n  if (callbackSet.size === 0) {\n    fidChangeCallbacks.delete(key);\n  }\n\n  // Close broadcast channel if there are no more callbacks.\n  closeBroadcastChannel();\n}\n\nfunction callFidChangeCallbacks(key: string, fid: string): void {\n  const callbacks = fidChangeCallbacks.get(key);\n  if (!callbacks) {\n    return;\n  }\n\n  for (const callback of callbacks) {\n    callback(fid);\n  }\n}\n\nfunction broadcastFidChange(key: string, fid: string): void {\n  const channel = getBroadcastChannel();\n  if (channel) {\n    channel.postMessage({ key, fid });\n  }\n  closeBroadcastChannel();\n}\n\nlet broadcastChannel: BroadcastChannel | null = null;\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\nfunction getBroadcastChannel(): BroadcastChannel | null {\n  if (!broadcastChannel && 'BroadcastChannel' in self) {\n    broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\n    broadcastChannel.onmessage = e => {\n      callFidChangeCallbacks(e.data.key, e.data.fid);\n    };\n  }\n  return broadcastChannel;\n}\n\nfunction closeBroadcastChannel(): void {\n  if (fidChangeCallbacks.size === 0 && broadcastChannel) {\n    broadcastChannel.close();\n    broadcastChannel = null;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DB, openDb } from 'idb';\nimport { AppConfig } from '../interfaces/installation-impl';\nimport { InstallationEntry } from '../interfaces/installation-entry';\nimport { getKey } from '../util/get-key';\nimport { fidChanged } from './fid-changed';\n\nconst DATABASE_NAME = 'firebase-installations-database';\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\n\nlet dbPromise: Promise<DB> | null = null;\nfunction getDbPromise(): Promise<DB> {\n  if (!dbPromise) {\n    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, upgradeDB => {\n      // We don't use 'break' in this switch statement, the fall-through\n      // behavior is what we want, because if there are multiple versions between\n      // the old version and the current version, we want ALL the migrations\n      // that correspond to those versions to run, not only the last one.\n      // eslint-disable-next-line default-case\n      switch (upgradeDB.oldVersion) {\n        case 0:\n          upgradeDB.createObjectStore(OBJECT_STORE_NAME);\n      }\n    });\n  }\n  return dbPromise;\n}\n\n/** Gets record(s) from the objectStore that match the given key. */\nexport async function get(\n  appConfig: AppConfig\n): Promise<InstallationEntry | undefined> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  return db\n    .transaction(OBJECT_STORE_NAME)\n    .objectStore(OBJECT_STORE_NAME)\n    .get(key);\n}\n\n/** Assigns or overwrites the record for the given key with the given value. */\nexport async function set<ValueType extends InstallationEntry>(\n  appConfig: AppConfig,\n  value: ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const objectStore = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue = await objectStore.get(key);\n  await objectStore.put(value, key);\n  await tx.complete;\n\n  if (!oldValue || oldValue.fid !== value.fid) {\n    fidChanged(appConfig, value.fid);\n  }\n\n  return value;\n}\n\n/** Removes record(s) from the objectStore that match the given key. */\nexport async function remove(appConfig: AppConfig): Promise<void> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n  await tx.complete;\n}\n\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */\nexport async function update<ValueType extends InstallationEntry | undefined>(\n  appConfig: AppConfig,\n  updateFn: (previousValue: InstallationEntry | undefined) => ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const store = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue: InstallationEntry | undefined = await store.get(key);\n  const newValue = updateFn(oldValue);\n\n  if (newValue === undefined) {\n    await store.delete(key);\n  } else {\n    await store.put(newValue, key);\n  }\n  await tx.complete;\n\n  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\n    fidChanged(appConfig, newValue.fid);\n  }\n\n  return newValue;\n}\n\nexport async function clear(): Promise<void> {\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).clear();\n  await tx.complete;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createInstallationRequest } from '../functions/create-installation-request';\nimport { AppConfig } from '../interfaces/installation-impl';\nimport {\n  InProgressInstallationEntry,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { generateFid, INVALID_FID } from './generate-fid';\nimport { remove, set, update } from './idb-manager';\n\nexport interface InstallationEntryWithRegistrationPromise {\n  installationEntry: InstallationEntry;\n  /** Exist iff the installationEntry is not registered. */\n  registrationPromise?: Promise<RegisteredInstallationEntry>;\n}\n\n/**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */\nexport async function getInstallationEntry(\n  appConfig: AppConfig\n): Promise<InstallationEntryWithRegistrationPromise> {\n  let registrationPromise: Promise<RegisteredInstallationEntry> | undefined;\n\n  const installationEntry = await update(appConfig, oldEntry => {\n    const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n    const entryWithPromise = triggerRegistrationIfNecessary(\n      appConfig,\n      installationEntry\n    );\n    registrationPromise = entryWithPromise.registrationPromise;\n    return entryWithPromise.installationEntry;\n  });\n\n  if (installationEntry.fid === INVALID_FID) {\n    // FID generation failed. Waiting for the FID from the server.\n    return { installationEntry: await registrationPromise! };\n  }\n\n  return {\n    installationEntry,\n    registrationPromise\n  };\n}\n\n/**\n * Creates a new Installation Entry if one does not exist.\n * Also clears timed out pending requests.\n */\nfunction updateOrCreateInstallationEntry(\n  oldEntry: InstallationEntry | undefined\n): InstallationEntry {\n  const entry: InstallationEntry = oldEntry || {\n    fid: generateFid(),\n    registrationStatus: RequestStatus.NOT_STARTED\n  };\n\n  return clearTimedOutRequest(entry);\n}\n\n/**\n * If the Firebase Installation is not registered yet, this will trigger the\n * registration and return an InProgressInstallationEntry.\n *\n * If registrationPromise does not exist, the installationEntry is guaranteed\n * to be registered.\n */\nfunction triggerRegistrationIfNecessary(\n  appConfig: AppConfig,\n  installationEntry: InstallationEntry\n): InstallationEntryWithRegistrationPromise {\n  if (installationEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n    if (!navigator.onLine) {\n      // Registration required but app is offline.\n      const registrationPromiseWithError = Promise.reject(\n        ERROR_FACTORY.create(ErrorCode.APP_OFFLINE)\n      );\n      return {\n        installationEntry,\n        registrationPromise: registrationPromiseWithError\n      };\n    }\n\n    // Try registering. Change status to IN_PROGRESS.\n    const inProgressEntry: InProgressInstallationEntry = {\n      fid: installationEntry.fid,\n      registrationStatus: RequestStatus.IN_PROGRESS,\n      registrationTime: Date.now()\n    };\n    const registrationPromise = registerInstallation(\n      appConfig,\n      inProgressEntry\n    );\n    return { installationEntry: inProgressEntry, registrationPromise };\n  } else if (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS\n  ) {\n    return {\n      installationEntry,\n      registrationPromise: waitUntilFidRegistration(appConfig)\n    };\n  } else {\n    return { installationEntry };\n  }\n}\n\n/** This will be executed only once for each new Firebase Installation. */\nasync function registerInstallation(\n  appConfig: AppConfig,\n  installationEntry: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  try {\n    const registeredInstallationEntry = await createInstallationRequest(\n      appConfig,\n      installationEntry\n    );\n    return set(appConfig, registeredInstallationEntry);\n  } catch (e) {\n    if (isServerError(e) && e.customData.serverCode === 409) {\n      // Server returned a \"FID can not be used\" error.\n      // Generate a new ID next time.\n      await remove(appConfig);\n    } else {\n      // Registration failed. Set FID as not registered.\n      await set(appConfig, {\n        fid: installationEntry.fid,\n        registrationStatus: RequestStatus.NOT_STARTED\n      });\n    }\n    throw e;\n  }\n}\n\n/** Call if FID registration is pending in another request. */\nasync function waitUntilFidRegistration(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry: InstallationEntry = await updateInstallationRequest(appConfig);\n  while (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n    // createInstallation request still in progress.\n    await sleep(100);\n\n    entry = await updateInstallationRequest(appConfig);\n  }\n\n  if (entry.registrationStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    const { installationEntry, registrationPromise } =\n      await getInstallationEntry(appConfig);\n\n    if (registrationPromise) {\n      return registrationPromise;\n    } else {\n      // if there is no registrationPromise, entry is registered.\n      return installationEntry as RegisteredInstallationEntry;\n    }\n  }\n\n  return entry;\n}\n\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateInstallationRequest(\n  appConfig: AppConfig\n): Promise<InstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!oldEntry) {\n      throw ERROR_FACTORY.create(ErrorCode.INSTALLATION_NOT_FOUND);\n    }\n    return clearTimedOutRequest(oldEntry);\n  });\n}\n\nfunction clearTimedOutRequest(entry: InstallationEntry): InstallationEntry {\n  if (hasInstallationRequestTimedOut(entry)) {\n    return {\n      fid: entry.fid,\n      registrationStatus: RequestStatus.NOT_STARTED\n    };\n  }\n\n  return entry;\n}\n\nfunction hasInstallationRequestTimedOut(\n  installationEntry: InstallationEntry\n): boolean {\n  return (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS &&\n    installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry\n} from '../interfaces/installation-entry';\nimport { PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\nimport {\n  FirebaseInstallationsImpl,\n  AppConfig\n} from '../interfaces/installation-impl';\n\nexport async function generateAuthTokenRequest(\n  { appConfig, platformLoggerProvider }: FirebaseInstallationsImpl,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers.append('x-firebase-client', platformLogger.getPlatformInfoString());\n  }\n\n  const body = {\n    installation: {\n      sdkVersion: PACKAGE_VERSION\n    }\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: GenerateAuthTokenResponse = await response.json();\n    const completedAuthToken: CompletedAuthToken =\n      extractAuthTokenInfoFromResponse(responseValue);\n    return completedAuthToken;\n  } else {\n    throw await getErrorFromResponse('Generate Auth Token', response);\n  }\n}\n\nfunction getGenerateAuthTokenEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { generateAuthTokenRequest } from '../functions/generate-auth-token-request';\nimport {\n  AppConfig,\n  FirebaseInstallationsImpl\n} from '../interfaces/installation-impl';\nimport {\n  AuthToken,\n  CompletedAuthToken,\n  InProgressAuthToken,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS, TOKEN_EXPIRATION_BUFFER } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { remove, set, update } from './idb-manager';\n\n/**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */\nexport async function refreshAuthToken(\n  installations: FirebaseInstallationsImpl,\n  forceRefresh = false\n): Promise<CompletedAuthToken> {\n  let tokenPromise: Promise<CompletedAuthToken> | undefined;\n  const entry = await update(installations.appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n      // There is a valid token in the DB.\n      return oldEntry;\n    } else if (oldAuthToken.requestStatus === RequestStatus.IN_PROGRESS) {\n      // There already is a token request in progress.\n      tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\n      return oldEntry;\n    } else {\n      // No token or token expired.\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      }\n\n      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n      tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\n      return inProgressEntry;\n    }\n  });\n\n  const authToken = tokenPromise\n    ? await tokenPromise\n    : (entry.authToken as CompletedAuthToken);\n  return authToken;\n}\n\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n *\n * Waits until the current pending request finishes. If the request times out,\n * tries once in this thread as well.\n */\nasync function waitUntilAuthTokenRequest(\n  installations: FirebaseInstallationsImpl,\n  forceRefresh: boolean\n): Promise<CompletedAuthToken> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry = await updateAuthTokenRequest(installations.appConfig);\n  while (entry.authToken.requestStatus === RequestStatus.IN_PROGRESS) {\n    // generateAuthToken still in progress.\n    await sleep(100);\n\n    entry = await updateAuthTokenRequest(installations.appConfig);\n  }\n\n  const authToken = entry.authToken;\n  if (authToken.requestStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    return refreshAuthToken(installations, forceRefresh);\n  } else {\n    return authToken;\n  }\n}\n\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateAuthTokenRequest(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n      return {\n        ...oldEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n    }\n\n    return oldEntry;\n  });\n}\n\nasync function fetchAuthTokenFromServer(\n  installations: FirebaseInstallationsImpl,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  try {\n    const authToken = await generateAuthTokenRequest(\n      installations,\n      installationEntry\n    );\n    const updatedInstallationEntry: RegisteredInstallationEntry = {\n      ...installationEntry,\n      authToken\n    };\n    await set(installations.appConfig, updatedInstallationEntry);\n    return authToken;\n  } catch (e) {\n    if (\n      isServerError(e) &&\n      (e.customData.serverCode === 401 || e.customData.serverCode === 404)\n    ) {\n      // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n      // Generate a new ID next time.\n      await remove(installations.appConfig);\n    } else {\n      const updatedInstallationEntry: RegisteredInstallationEntry = {\n        ...installationEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n      await set(installations.appConfig, updatedInstallationEntry);\n    }\n    throw e;\n  }\n}\n\nfunction isEntryRegistered(\n  installationEntry: InstallationEntry | undefined\n): installationEntry is RegisteredInstallationEntry {\n  return (\n    installationEntry !== undefined &&\n    installationEntry.registrationStatus === RequestStatus.COMPLETED\n  );\n}\n\nfunction isAuthTokenValid(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.COMPLETED &&\n    !isAuthTokenExpired(authToken)\n  );\n}\n\nfunction isAuthTokenExpired(authToken: CompletedAuthToken): boolean {\n  const now = Date.now();\n  return (\n    now < authToken.creationTime ||\n    authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER\n  );\n}\n\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\nfunction makeAuthTokenRequestInProgressEntry(\n  oldEntry: RegisteredInstallationEntry\n): RegisteredInstallationEntry {\n  const inProgressAuthToken: InProgressAuthToken = {\n    requestStatus: RequestStatus.IN_PROGRESS,\n    requestTime: Date.now()\n  };\n  return {\n    ...oldEntry,\n    authToken: inProgressAuthToken\n  };\n}\n\nfunction hasAuthTokenRequestTimedOut(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.IN_PROGRESS &&\n    authToken.requestTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { FirebaseInstallationsImpl } from '../interfaces/installation-impl';\nimport { Installations } from '../interfaces/public-types';\n\n/**\n * Creates a Firebase Installation if there isn't one for the app and\n * returns the Installation ID.\n * @param installations - The `Installations` instance.\n *\n * @public\n */\nexport async function getId(installations: Installations): Promise<string> {\n  const installationsImpl = installations as FirebaseInstallationsImpl;\n  const { installationEntry, registrationPromise } = await getInstallationEntry(\n    installationsImpl.appConfig\n  );\n\n  if (registrationPromise) {\n    registrationPromise.catch(console.error);\n  } else {\n    // If the installation is already registered, update the authentication\n    // token if needed.\n    refreshAuthToken(installationsImpl).catch(console.error);\n  }\n\n  return installationEntry.fid;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport {\n  FirebaseInstallationsImpl,\n  AppConfig\n} from '../interfaces/installation-impl';\nimport { Installations } from '../interfaces/public-types';\n\n/**\n * Returns a Firebase Installations auth token, identifying the current\n * Firebase Installation.\n * @param installations - The `Installations` instance.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nexport async function getToken(\n  installations: Installations,\n  forceRefresh = false\n): Promise<string> {\n  const installationsImpl = installations as FirebaseInstallationsImpl;\n  await completeInstallationRegistration(installationsImpl.appConfig);\n\n  // At this point we either have a Registered Installation in the DB, or we've\n  // already thrown an error.\n  const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\n  return authToken.token;\n}\n\nasync function completeInstallationRegistration(\n  appConfig: AppConfig\n): Promise<void> {\n  const { registrationPromise } = await getInstallationEntry(appConfig);\n\n  if (registrationPromise) {\n    // A createInstallation request is in progress. Wait until it finishes.\n    await registrationPromise;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/installation-impl';\nimport { RegisteredInstallationEntry } from '../interfaces/installation-entry';\nimport {\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function deleteInstallationRequest(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<void> {\n  const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n  const request: RequestInit = {\n    method: 'DELETE',\n    headers\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (!response.ok) {\n    throw await getErrorFromResponse('Delete Installation', response);\n  }\n}\n\nfunction getDeleteEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deleteInstallationRequest } from '../functions/delete-installation-request';\nimport { remove, update } from '../helpers/idb-manager';\nimport { RequestStatus } from '../interfaces/installation-entry';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\nimport { FirebaseInstallationsImpl } from '../interfaces/installation-impl';\nimport { Installations } from '../interfaces/public-types';\n\n/**\n * Deletes the Firebase Installation and all associated data.\n * @param installations - The `Installations` instance.\n *\n * @public\n */\nexport async function deleteInstallations(\n  installations: Installations\n): Promise<void> {\n  const { appConfig } = installations as FirebaseInstallationsImpl;\n\n  const entry = await update(appConfig, oldEntry => {\n    if (oldEntry && oldEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n      // Delete the unregistered entry without sending a deleteInstallation request.\n      return undefined;\n    }\n    return oldEntry;\n  });\n\n  if (entry) {\n    if (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n      // Can't delete while trying to register.\n      throw ERROR_FACTORY.create(ErrorCode.DELETE_PENDING_REGISTRATION);\n    } else if (entry.registrationStatus === RequestStatus.COMPLETED) {\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      } else {\n        await deleteInstallationRequest(appConfig, entry);\n        await remove(appConfig);\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { addCallback, removeCallback } from '../helpers/fid-changed';\nimport { FirebaseInstallationsImpl } from '../interfaces/installation-impl';\nimport { Installations } from '../interfaces/public-types';\n\n/**\n * An user defined callback function that gets called when Installations ID changes.\n *\n * @public\n */\nexport type IdChangeCallbackFn = (installationId: string) => void;\n/**\n * Unsubscribe a callback function previously added via {@link #IdChangeCallbackFn}.\n *\n * @public\n */\nexport type IdChangeUnsubscribeFn = () => void;\n\n/**\n * Sets a new callback that will get called when Installation ID changes.\n * Returns an unsubscribe function that will remove the callback when called.\n * @param installations - The `Installations` instance.\n * @param callback - The callback function that is invoked when FID changes.\n * @returns A function that can be called to unsubscribe.\n *\n * @public\n */\nexport function onIdChange(\n  installations: Installations,\n  callback: IdChangeCallbackFn\n): IdChangeUnsubscribeFn {\n  const { appConfig } = installations as FirebaseInstallationsImpl;\n\n  addCallback(appConfig, callback);\n  return () => {\n    removeCallback(appConfig, callback);\n  };\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, getApp, _getProvider } from '@firebase/app';\nimport { Installations } from '../interfaces/public-types';\n\n/**\n * Returns an instance of {@link Installations} associated with the given\n * {@link @firebase/app#FirebaseApp} instance.\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\n *\n * @public\n */\nexport function getInstallations(app: FirebaseApp = getApp()): Installations {\n  const installationsImpl = _getProvider(app, 'installations').getImmediate();\n  return installationsImpl;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, FirebaseOptions } from '@firebase/app';\nimport { FirebaseError } from '@firebase/util';\nimport { AppConfig } from '../interfaces/installation-impl';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function extractAppConfig(app: FirebaseApp): AppConfig {\n  if (!app || !app.options) {\n    throw getMissingValueError('App Configuration');\n  }\n\n  if (!app.name) {\n    throw getMissingValueError('App Name');\n  }\n\n  // Required app config keys\n  const configKeys: Array<keyof FirebaseOptions> = [\n    'projectId',\n    'apiKey',\n    'appId'\n  ];\n\n  for (const keyName of configKeys) {\n    if (!app.options[keyName]) {\n      throw getMissingValueError(keyName);\n    }\n  }\n\n  return {\n    appName: app.name,\n    projectId: app.options.projectId!,\n    apiKey: app.options.apiKey!,\n    appId: app.options.appId!\n  };\n}\n\nfunction getMissingValueError(valueName: string): FirebaseError {\n  return ERROR_FACTORY.create(ErrorCode.MISSING_APP_CONFIG_VALUES, {\n    valueName\n  });\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { _registerComponent, _getProvider } from '@firebase/app';\nimport {\n  Component,\n  ComponentType,\n  InstanceFactory,\n  ComponentContainer\n} from '@firebase/component';\nimport { getId, getToken } from '../api/index';\nimport { _FirebaseInstallationsInternal } from '../interfaces/public-types';\nimport { FirebaseInstallationsImpl } from '../interfaces/installation-impl';\nimport { extractAppConfig } from '../helpers/extract-app-config';\n\nconst INSTALLATIONS_NAME = 'installations';\nconst INSTALLATIONS_NAME_INTERNAL = 'installations-internal';\n\nconst publicFactory: InstanceFactory<'installations'> = (\n  container: ComponentContainer\n) => {\n  const app = container.getProvider('app').getImmediate();\n  // Throws if app isn't configured properly.\n  const appConfig = extractAppConfig(app);\n  const platformLoggerProvider = _getProvider(app, 'platform-logger');\n\n  const installationsImpl: FirebaseInstallationsImpl = {\n    app,\n    appConfig,\n    platformLoggerProvider,\n    _delete: () => Promise.resolve()\n  };\n  return installationsImpl;\n};\n\nconst internalFactory: InstanceFactory<'installations-internal'> = (\n  container: ComponentContainer\n) => {\n  const app = container.getProvider('app').getImmediate();\n  // Internal FIS instance relies on public FIS instance.\n  const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();\n\n  const installationsInternal: _FirebaseInstallationsInternal = {\n    getId: () => getId(installations),\n    getToken: (forceRefresh?: boolean) => getToken(installations, forceRefresh)\n  };\n  return installationsInternal;\n};\n\nexport function registerInstallations(): void {\n  _registerComponent(\n    new Component(INSTALLATIONS_NAME, publicFactory, ComponentType.PUBLIC)\n  );\n  _registerComponent(\n    new Component(\n      INSTALLATIONS_NAME_INTERNAL,\n      internalFactory,\n      ComponentType.PRIVATE\n    )\n  );\n}\n", "/**\n * Firebase Installations\n *\n * @packageDocumentation\n */\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { registerInstallations } from './functions/config';\nimport { registerVersion } from '@firebase/app';\nimport { name, version } from '../package.json';\n\nexport * from './api';\nexport * from './interfaces/public-types';\n\nregisterInstallations();\nregisterVersion(name, version);\n// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\nregisterVersion(name, version, '__BUILD_TARGET__');\n"],
  "mappings": "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",
  "names": []
}
